# Windbg

## Memo Commands

| WinDBG Cmd | Info |  |
| :--- | :---: | :--- |
| `F6` | Attach |  |
| `g / F5` | run |  |
| `.cls` | clear command screen |  |
| `u` | Unassemble from memory. “u” needs an argument or it will read from the beginning of the EIP. Can also check windows API argument = range or one simple memory address → `u Kernel32!GetCurrentThread` \= get current process |  |
| `db esp` | display byte + Register.Can also use specific address, eg `db A1B2C3D4` or symbol names, eg `db kernel32!WriteFile`. |  |
| `db esp L2` | Display 2 bytes |  |
| `da` | display ASCII |  |
| `dc` | Double-word values \(4 bytes\) and ASCII characters. Each display line shows the address of the first word in the line and up to eight hexadecimal word values, as well as their ASCII equivalent. The default count is 32 DWORDs \(128 bytes\). |  |
| `du` | display Unicode |  |
| `dw` | display words instead of bytes, eg dw + register |  |
| `dd` | display Dword |  |
| `dds` | display raw stack data + possible symbol info |  |
| `poi` | display reference address.     `dd esp L1` then `dd 77c6dca9` is equivalent to **dd poi\(esp\)** |  |
| `dW esp L2` | display 2 words + ASCII |  |
| `dc KERNELBASE` | print ASCII chars |  |
| `dq` | display Qword, eg dq + hex value |  |
| `dW` | display ASCII and DWORD, eg `DW kernelBase+0x40` ⇒ or dc, eg `dc kernelBase+0x40` |  |
| `dc esp L4` | will only print 4 Lines |  |
| `dt` | Display type, observe data structures |  |
| `dt ntdll!_TEB` | Display structure and his offset |  |
| `dt -r ntdll!_TEB @$teb` | recursively display nested structures |  |
| `dt ntdll!_TEB_ @$teb ThreadLocalStoragePointer` | display a specific TEB |  |
| `?? sizeof(ntdll!_TEB)` | display the size of a structure extracted from symbol file |  |
| `ed` | edit/write value into a pecific memory address, eg `dd esp L1` then `ed esp 41414141` |  |
| `ea` | change/edit ASCII value |  |
| `eu` | change/edit UTF-8 value |  |
| `ed` | change/edit DWORD value |  |
| `s` | search debug memnory space |  |
| `s -a 0  L?80000000 "This program connot be run in DOS mode"` | searching for a string |  |
| `s -d <searching address> <\search whole memory range, ie L?80000000> \` | search for DWORD AAAA memory type from 0 to the end |  |
| `r` | dump register \(can be used with specific register, ie `r edx` \) |  |
| `r ecx=41414141` | Edit register value |  |
| `lm m ole32` | search for the module ole32 |  |
| `.reload /f` | reload if new symbols have been uploaded. |  |
| `bu ole32!WriteStringStream` | search for the function WriteStringStream for the loaded module ole32 |  |
| `bp kerknel32!WriteFile ".printf \The number of bytes written is: %p\", poi(esp + 0x0c); .echo;g` | display the number of bytes written using a breakpoint on WriteFile function |  |
| `p` | execute one single instruction at the time and step into functions calls |  |
| `ph` | The **ph** command executes the program until any kind of branching instruction is reached, including conditional or unconditional branches, calls, returns, and system calls. |  |
| `pt` | step to the next return \(fast forward to the end of the function\) |  |
| `t` | step into a nested functions calls \(function within another function\) |  |
| `!exchain` | Automatically list the current thread exception handler chain |  |
| `k` | Inspect the callstack |  |

### Break Points

| WinDBG Cmd | Info |
| :--- | :---: |
| `bp kernel32!WriteFile` | set a break point on WriteFile function |
| `bl` | list break point |
| `bd` | disable break point |
| `be` | enable break point |
| `bc` | clear break point |
| `bu` | display unresolved function \(not already loaded into the memory space\) |

#### Conditional breakpoints

Display result if the number of written byte is equal to 4

```csharp
# gc = continue the execution flow
bp kernel32!WriteFile ".if (poi(esp + 0x0c) !=4 ) {gc} .else {.printf \"the number of bytes written is 4 !\" ; .echo;}"
```

#### Hardware breakpoint

Useful to find specific data when running a program. `ba` command which requires 3 arguments:

* type of access \(e for execute r for read and w for write\)
* size in byte of the specified memory access
* address of the wanted break point

```csharp
ba e 1 kernel32!WriteFile
```

### Listing modules and Symbols

| WinDBG Cmd | Info |
| :--- | :--- |
| `.reload /f` | reload to identify new uploaded |
| `lm m kernel*` | search for a modules which starts with kernel |
| `x kernelbase!CreateProc*` | dump symbols |

### Data format

| WinDBG Cmd | Info |
| :--- | :--- |
| `? 41414141` | to decimal |
| `? 0n41414141` | to hexadecimal |
| `? 0y 1111111011100010` | binary to decimal and hexadecimal |
| `.formats` | convert everything at once |

### Calculator function

| WinDBG Cmd | Info |
| :--- | :--- |
| `? 11223344 - 0a0b0c0d` | Substraction |
| `? 0a0b0c0d >> 18` | shifting an address to 18 bytes |

### Pseudo registers

There are 20 user-defined pseudo registers named `$t0 to $t19`

→ prefix them with the “@” character

```csharp
? ((41414141 - 414141) * 0n10) >> 8
# same as :
r @$t0 = (41414141 - 414141) * 0n10
r @$t0
? @$t0 >> 8
```

### Resources

{% embed url="http://windbg.info/doc/1-common-cmds.html" %}

